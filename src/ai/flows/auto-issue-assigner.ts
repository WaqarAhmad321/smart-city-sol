
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview Automatically assigns field workers to areas with a high number of pending issues.
 *
 * - autoAssignFieldWorker - A function that triggers the automatic assignment of field workers.
 * - AutoAssignFieldWorkerInput - The input type for the autoAssignFieldWorker function.
 * - AutoAssignFieldWorkerOutput - The return type for the autoAssignFieldWorker function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import { collection, query, where, getDocs, limit } from 'firebase/firestore';
import { db } from '@/lib/firebase'; // Import Firestore instance

const AutoAssignFieldWorkerInputSchema = z.object({
  area: z.string().describe('The geographic area to check for pending issues. This should match the locationAddress field in issues.'),
  issueThreshold: z.number().describe('The number of pending issues that triggers assignment.'),
});
export type AutoAssignFieldWorkerInput = z.infer<typeof AutoAssignFieldWorkerInputSchema>;

const AutoAssignFieldWorkerOutputSchema = z.object({
  assignedWorker: z.string().nullable().describe('The ID of the field worker assigned to the area, or null if no assignment was needed.'),
  numPendingIssues: z.number().describe('The number of pending issues in the area.'),
  message: z.string().describe('A message describing the outcome.'),
});
export type AutoAssignFieldWorkerOutput = z.infer<typeof AutoAssignFieldWorkerOutputSchema>;

export async function autoAssignFieldWorker(input: AutoAssignFieldWorkerInput): Promise<AutoAssignFieldWorkerOutput> {
  return autoAssignFieldWorkerFlow(input);
}

const getPendingIssueCount = ai.defineTool(
  {
    name: 'getPendingIssueCount',
    description: 'Retrieves the number of pending issues (status "Pending" or "Assigned") in a specific geographic area by querying the locationAddress field.',
    inputSchema: z.object({
      area: z.string().describe('The geographic area (e.g., street name, neighborhood) to check, matching locationAddress.'),
    }),
    outputSchema: z.number().describe('The number of pending issues in the area.'),
  },
  async (input) => {
    console.log(`Genkit Tool: getPendingIssueCount for area: ${input.area}`);
    try {
      const issuesRef = collection(db, 'issues');
      // Firestore's `where` clause with `includes` or `startsWith` on `locationAddress` is not directly supported for substring matches.
      // For a production app, you might need a more sophisticated search solution (e.g., Algolia, Elasticsearch)
      // or structure your data to allow for exact matches on area fields (e.g., a dedicated 'area' field).
      // For this example, we'll attempt a broad query and client-side filter if necessary, or a more precise query if possible.
      // This simple query will look for exact match or use a more complex setup if needed.
      // Let's assume 'area' is a general term and we are looking for issues with status 'Pending' or 'Assigned'.
      
      // Query for issues that are 'Pending' OR 'Assigned'. Firestore requires separate queries for OR conditions on different fields or an `in` operator.
      const pendingQuery = query(issuesRef, where('status', '==', 'Pending'), where('locationAddress', '>=', input.area), where('locationAddress', '<=', input.area + '\uf8ff'), limit(100));
      const assignedQuery = query(issuesRef, where('status', '==', 'Assigned'), where('locationAddress', '>=', input.area), where('locationAddress', '<=', input.area + '\uf8ff'), limit(100));
      
      const [pendingSnapshot, assignedSnapshot] = await Promise.all([
        getDocs(pendingQuery),
        getDocs(assignedQuery)
      ]);
      
      const uniqueIssues = new Set<string>();
      pendingSnapshot.docs.forEach(doc => {
        // A more robust check would be to ensure the locationAddress truly contains the area string,
        // as the Firestore range query is a prefix match.
        if (doc.data().locationAddress?.toLowerCase().includes(input.area.toLowerCase())) {
             uniqueIssues.add(doc.id);
        }
      });
      assignedSnapshot.docs.forEach(doc => {
         if (doc.data().locationAddress?.toLowerCase().includes(input.area.toLowerCase())) {
            uniqueIssues.add(doc.id);
        }
      });

      console.log(`Found ${uniqueIssues.size} pending/assigned issues in area: ${input.area}`);
      return uniqueIssues.size;
    } catch (error) {
      console.error('Error in getPendingIssueCount tool:', error);
      throw new Error(`Failed to get pending issue count for area ${input.area}.`);
    }
  }
);

const assignFieldWorker = ai.defineTool(
  {
    name: 'assignFieldWorker',
    description: 'Assigns a field worker to a specific geographic area or a set of issues. (Firebase integration TODO)',
    inputSchema: z.object({
      area: z.string().describe('The geographic area to assign the worker to.'),
      workerId: z.string().describe('The ID of the field worker to assign.'),
      // issueIds: z.array(z.string()).optional().describe('Specific issue IDs to assign to this worker'),
    }),
    outputSchema: z.string().describe('Confirmation message of worker assignment.'),
  },
  async (input) => {
    // TODO: Implement the logic to assign the field worker in the database.
    // This would involve:
    // 1. Finding an available worker (query 'users' collection where role is 'official' and perhaps an 'availability' status).
    // 2. If specific issueIds are provided, update those issues in Firestore with assignedTo = workerId and status = 'Assigned'.
    // 3. If only an area is provided, this tool might just log the assignment or create a general task for the worker.
    // 4. Update worker's task list or assignment count.
    console.log(`Genkit Tool: assignFieldWorker - Assigning worker ${input.workerId} to area: ${input.area}`);
    // This is a placeholder. Real implementation needs Firestore updates.
    return `Worker ${input.workerId} has been notionally assigned to ${input.area}. (Firebase update not yet implemented)`;
  }
);

const autoAssignFieldWorkerPrompt = ai.definePrompt({
  name: 'autoAssignFieldWorkerPrompt',
  input: {schema: AutoAssignFieldWorkerInputSchema},
  output: {schema: AutoAssignFieldWorkerOutputSchema},
  tools: [getPendingIssueCount, assignFieldWorker],
  prompt: `You are an AI assistant helping to manage field worker assignments for city maintenance.

  The administrator wants to automatically assign field workers to areas where the number of pending issues (status "Pending" or "Assigned") exceeds a certain threshold.

  Current area: {{{area}}}
  Issue threshold: {{{issueThreshold}}}

  First, use the getPendingIssueCount tool to determine the number of pending issues in the specified area. The area name should be used to query the locationAddress field of the issues.

  If the number of pending issues is greater than the issueThreshold, use the assignFieldWorker tool to assign a field worker to the area. For this simulation, you can assign a generic worker ID like "worker-default-001".
  
  Respond with the ID of the assigned worker (or null if no assignment was needed), the number of pending issues found, and a descriptive message.
  If no assignment was needed, return null for the assignedWorker field and explain why in the message.
  `,
});

const autoAssignFieldWorkerFlow = ai.defineFlow(
  {
    name: 'autoAssignFieldWorkerFlow',
    inputSchema: AutoAssignFieldWorkerInputSchema,
    outputSchema: AutoAssignFieldWorkerOutputSchema,
  },
  async (input) => {
    const llmResponse = await autoAssignFieldWorkerPrompt(input);
    
    if (!llmResponse.output) {
        // Handle cases where the LLM might not provide a structured output as expected
        // or if a tool call failed and the LLM couldn't recover.
        const pendingIssues = await getPendingIssueCount(input); // Try to get a direct count
        if (pendingIssues > input.issueThreshold) {
            return {
                assignedWorker: null, // LLM failed to assign
                numPendingIssues: pendingIssues,
                message: `LLM response incomplete. Found ${pendingIssues} issues (threshold: ${input.issueThreshold}). Manual assignment might be needed.`,
            };
        }
        return {
            assignedWorker: null,
            numPendingIssues: pendingIssues,
            message: `LLM response incomplete. Found ${pendingIssues} issues (threshold: ${input.issueThreshold}). No assignment triggered.`,
        };
    }
    
    // Ensure the output from the LLM (after tool use) is correctly formed.
    // The LLM should have called the tools and formulated the final response.
    return llmResponse.output;
  }
);
